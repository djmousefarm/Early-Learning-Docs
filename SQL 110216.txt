SQL, 'Structured Query Language', is a programming language designed to manage data stored in relational databases. SQL operates through simple, declarative statements. This keeps data accurate and secure, and helps maintain the integrity of databases, regardless of size.

The SQL language is widely used today across web frameworks and database applications. Knowing SQL gives you the freedom to explore your data, and the power to make better decisions. By learning SQL, you will also learn concepts that apply to nearly every data storage system.

The statements covered in this course, use SQLite Relational Database Management System (RDBMS)

SQL :

SELECT * FROM celebs;

Nice work. In one line of code, you returned information from a relational database. We'll take a look at what this code means soon, for now let's focus on what relational databases are and how they are organized.

1. A relational database is a database that organizes information into one or more tables. Here the relational database contains one table. 
 2. A table is a collection of data organized into rows and columns. Tables are sometimes referred to as relations. Here the table is celebs. 
 3. A column is a set of data values of a particular type. Here id, name, and age are each columns. 
 4. A row is a single record in a table. The first row in the celebs table has:

◼An id of 1
◼A name of Justin Bieber
◼An age of 22

All data stored in a relational database is of a certain data type. Some of the most common data types are: 

1. Integer, a positive or negative whole number 
 2. Text, a text string 
 3. Date, the date formatted as YYYY-MM-DD for the year, month, and day 
 4. Real, a decimal value 

SQL :

CREATE TABLE table_name (
    column_1 data_type, 
    column_2 data_type, 
    column_3 data_type
  );


The above code is a SQL statement. A statement is text that the database recognizes as a valid command. Statements always end in a semi-colon ;. 

Let's break down the components of a statement:
1.CREATE TABLE is a clause. Clauses perform specific tasks in SQL. By convention, clauses are written in capital letters. Clauses can also be referred to as commands.
2.table_name refers to the name of the table that the command is applied to. 
3.(column_1 data_type, column_2 data_type, column_3 data_type) is a parameter. A parameter is a list of columns, data types, or values that are passed to a clause as an argument. Here, the parameter is a list of column names and the associated data type.

The structure of SQL statements vary. The number of lines used do not matter. A statement can be written all on one line, or split up across multiple lines if it makes it easier to read. In this course, you will become familiar with the structure of common statements.

SQL :

CREATE TABLE celebs (id INTEGER, name TEXT, age INTEGER);

This CREATE statement creates a new table in the database named celebs. You can use the CREATE statement anytime you want to create a new table from scratch.

1. CREATE TABLE is a clause that tells SQL you want to create a new table. 
 2. celebs is the name of the table. 
 3. (id INTEGER, name TEXT, age INTEGER) is a list of parameters defining each column in the table and its data type. 

◼id is the first column in the table. It stores values of data type INTEGER
◼name is the second column in the table. It stores values of data type TEXT
◼age is the third column in the table. It stores values of data type INTEGER

SQL : 

INSERT INTO celebs (id, name, age) VALUES (1, 'Justin Bieber', 21);

SELECT * FROM celebs;

The first line here adds a record into the table created in the previou section.
The second line requests the entire content of the table.

SQL : (Breaking down the SQL used in the previous section)

INSERT INTO celebs (id, name, age) VALUES (1, 'Justin Bieber', 21);

This INSERT statement inserts new rows into a table. You can use the INSERT statement when you want to add new records.

1. INSERT INTO is a clause that adds the specified row or rows. 
 2. celebs is the name of the table the row is added to. 
 3. (id, name, age) is a parameter identifying the columns that data will be inserted into. 
 4. VALUES is a clause that indicates the data being inserted. 
(1, 'Justin Bieber', 21) is a parameter identifying the values being inserted.
◼1 is an integer that will be inserted into the id column
◼'Justin Bieber' is text that will be inserted into the name column
◼21 is an integer that will be inserted into the age column

SQL: 

SELECT name FROM celebs;

SELECT statements are used to fetch data from a database. Here, SELECT returns all data in the name column of the celebs table.

1. SELECT is a clause that indicates that the statement is a query. You will use SELECT every time you query data from a database. 
 2. name specifies the column to query data from. 
 3. FROM celebs specifies the name of the table to query data from. In this statement, data is queried from the celebs table. 

You can also query data from all columns in a table with SELECT.
SELECT * FROM celebs;

* is a special wildcard character that we have been using. It allows you to select every column in a table without having to name each one individually. Here, the result set contains every column in the celebs table.

SELECT statements always return a new table called the result set.

SQL :

UPDATE celebs
SET age = 22
WHERE id = 1;

SELECT * FROM celebs;

The UPDATE statement edits a row in the table. You can use the UPDATE statement when you want to change existing records.

1. UPDATE is a clause that edits a row in the table. 
 2. celebs is the name of the table. 
 3. SET is a clause that indicates the column to edit. 
◼age is the name of the column that is going to be updated
◼22 is the new value that is going to be inserted into the age column.

4. WHERE is a clause that indicates which row(s) to update with the new column value. Here the row with a 1 in the id column is the row that will have the age updated to 22.

SQL:

ALTER TABLE celebs ADD COLUMN twitter_handle TEXT;

SELECT * FROM celebs;

The ALTER TABLE statement added a new column to the table. You can use this command when you want to add columns to a table.

1. ALTER TABLE is a clause that lets you make the specified changes. 
 2. celebs is the name of the table that is being changed. 
 3. ADD COLUMN is a clause that lets you add a new column to a table. 

◼twitter_handle is the name of the new column being added
◼TEXT is the data type for the new column

 4. NULL is a special value in SQL that represents missing or unknown data. Here, the rows that existed before the column was added have NULL values for twitter_handle.

SQL:

DELETE FROM celebs WHERE twitter_handle IS NULL;

The DELETE FROM statement deletes one or more rows from a table. You can use the statement when you want to delete existing records.
1.DELETE FROM is a clause that lets you delete rows from a table.
2.celebs is the name of the table we want to delete rows from.
3.WHERE is a clause that lets you select which rows you want to delete. Here we want to delete all of the rows where the twitter_handle column IS NULL.
4.IS NULL is a condition in SQL that returns true when the value is NULL and false otherwise. 

In summary;

SQL is a programming language designed to manipulate and manage data stored in relational databases.
A relational database is a database that organizes information into one or more tables.
A table is a collection of data organized into rows and columns.

A statement is a string of characters that the database recognizes as a valid command.
CREATE TABLE creates a new table.
INSERT INTO adds a new row to a table.
SELECT queries data from a table. 
UPDATE edits a row in a table.
ALTER TABLE changes an existing table.
DELETE FROM deletes rows from a table.

QUERIES

One of the core purposes of the SQL language is to retrieve information stored in a database. This is commonly referred to as querying. Queries allow us to communicate with the database by asking questions and having the result set return data relevant to the question. In this lesson, you will be querying a database with one table named movies. Let's get started.

Let's take a look at the name and imdb_rating of every movie in the database.

In the code editor type
SELECT name, imdb_rating FROM movies;

(This returns a list of movies and their imdb ratings)

Multiple columns can be queried at once by separating column names with a comma. By specifying name, imdb_rating, the result set contains a name and imdb_rating column.

Instructions

1. Let's continue with the SELECT statement. In the code editor, type

SELECT DISTINCT genre FROM movies;

(This returns only the unique values in the table, so there's only 6 output, whereas the previous list was hundreds)

SELECT DISTINCT is used to return unique values in the result set. It filters out all duplicate values. Here, the result set lists each genre in the movies table exactly once.

1. SELECT DISTINCT specifies that the statement is going to be a query that returns unique values in the specified column(s)

2. genre is the name of the column to display in the result set.

3. FROM movies indicates the table name to query from.

Filtering the results of a query is an important skill in SQL. It is easier to see the different possible genres a movie can have after the data has been filtered, than to scan every row in the table.

The rest of this lesson will teach you different commands in SQL to filter the results of a query.

The way to filter queries in SQL is to use the WHERE clause. In the code editor type
 
 SELECT * FROM movies WHERE imdb_rating > 8;

This statement filters the result set to only include movies with IMDb ratings greater than 8. How does it work?

1. WHERE is a clause that indicates you want to filter the result set to include only rows where the following condition is true.

2. imdb_rating > 8 is a condition that filters the result set. Here, only rows with a value greater than 8 in the imdb_rating column will be returned in the result set.

3. > is an operator. Operators create a condition that can be evaluated as either true or false. Common operators used with the WHERE clause are:
◼= equals
◼!= not equals
◼> greater than
◼< less than
◼>= greater than or equal to
◼<= less than or equal to

There are also some special operators that we will learn more about in the upcoming exercises.

LIKE is a special operator that can be used in a WHERE clause. In the code editor type

SELECT * FROM movies
WHERE name LIKE 'Se_en';

LIKE can be a useful operator when you want to compare similar values. Here, we are comparing two movies with the same name but are spelled differently.

1. LIKE is a special operator used with the WHERE clause to search for a specific pattern in a column.

2. name LIKE Se_en is a condition evaluating the name column for a specific pattern.

3. Se_en represents a pattern with a wildcard character. The _ means you can substitute any individual character here without breaking the pattern. The names Seven and Se7en both match this pattern.

% is another wildcard character that can be used with LIKE. We will learn more about % in the next exercise.


SELECT * FROM movies WHERE name LIKE 'A%';

This statement filters the result set to only include movies with names that begin with the letter "A"

% is a wildcard character that matches zero or more missing letters in the pattern.
◼A% matches all movies with names that begin with "A"
◼%a matches all movies that end with "a"

SELECT * FROM movies WHERE name LIKE '%man%';

You can use % both before and after a pattern. Here, any movie that contains the word "man" in its name will be returned in the result set. Notice, that LIKE is not case sensitive. "Batman" and "Man Of Steel" both appear in the result set. 

The BETWEEN operator is used to filter the result set within a certain range. The values can be numbers, text or dates.

SELECT * FROM movies WHERE name BETWEEN 'A' AND 'J';

This statement filters the result set to only include movies with names that begin with letters "A" up to but not including "J".

SELECT * FROM movies WHERE year BETWEEN 1990 AND 2000;

In this statement, the BETWEEN operator is being used to filter the result set to only include movies with years between 1990 up to and including 2000.

SELECT * FROM movies WHERE year BETWEEN 1990 and 2000 AND genre = 'comedy';

Sometimes you want to combine multiple conditions in a WHERE clause to make the result set more specific and useful. One way of doing this is to use the AND operator.

1. year BETWEEN 1990 and 2000 is the first condition in the WHERE clause.

2. AND genre = 'comedy' is the second condition in the WHERE clause.

3. AND is an operator that combines two conditions. Both conditions must be true for the row to be included in the result set. Here, we use the AND operator to only return movies made between 1990 and 2000 that are also comedies.

SELECT * FROM movies ORDER BY imdb_rating DESC;

You can sort the results of your query using ORDER BY. Sorting the results often makes the data more useful and easier to analyze.

1. ORDER BY is a clause that indicates you want to sort the result set by a particular column either alphabetically or numerically.

2. imdb_rating is the name of the column that will be sorted.

3. DESC is a keyword in SQL that is used with ORDER BY to sort the results in descending order (high to low or Z-A). Here, it sorts all of the movies from highest to lowest by their IMDb rating.

It is also possible to sort the results in ascending order. ASC is a keyword in SQL that is used with ORDER BY to sort the results in ascending order (low to high or A-Z).

SELECT * FROM movies ORDER BY imdb_rating DESC LIMIT 3;

Sometimes even filtered results can return thousands of rows in large databases. In these situations it becomes important to cap the number of rows in a result set.

LIMIT is a clause that lets you specify the maximum number of rows the result set will have. Here, we specify that the result set can not have more than three rows.

Summary : 

Congratulations! You just learned how to query data from a database using SQL. What can we generalize so far?

SELECT is the clause you use every time you want to query information from a database.

WHERE is a popular command that lets you filter the results of the query based on conditions that you specify.

LIKE and BETWEEN are special operators that can be used in a WHERE clause

AND and OR are special operators that you can use with WHERE to filter the query on two or more conditions.

ORDER BY lets you sort the results of the query in either ascending or descending order.

LIMIT lets you specify the maximum number of rows that the query will return. This is especially important in large tables that have thousands or even millions of rows.

SQL : Analysing Business Metrics

At the heart of every great business decision is data. Since most businesses store critical data in SQL databases, a deep understanding of SQL is a necessary skill for every data analyst. 

Chief among data analysis tasks is data aggregation, the grouping of data to express in summary form. We'll be working with SpeedySpoon, a meal delivery app. The folks at SpeedySpoon have asked us to look into their deliveries and help them optimize their process.

SQL : 

select * from order_items order by id limit 100;

Generate a list of 100 items from order_items table.

Now that we have a good handle on our data, let's dive into some common business queries. We'll begin with the Daily Count of orders placed. To make our Daily Count metric, we'll focus on the date function and the ordered_at field.

To get the Daily Metrics we need the date. Most dates in databases are timestamps, which have hours and minutes, as well as the year, month, and day. Timestamps look like 2015-01-05 14:43:31, while dates are the first part: 2015-01-05.

We can easily select the date an item was ordered at with the date function and the ordered_at field:

select date(ordered_at) from orders;


Let's get a Daily Count of orders from the orders table. Complete the query using the date function to cast the timestamps in ordered_at to dates.

select date(ordered_at) from orders order by 1 limit 100;

The order by 1 statement is a shortcut for order by date(ordered_at). The 1 refers to the first column.

Now that we can convert timestamps to dates, we can count the Orders Per Date. Generally, when we count all records in a table we run a query with the count function, as follows:

select count(1) from users;

This will treat all rows as a single group, and return one row in the result set - the total count.

To count orders by their dates, we'll use the date and count functions and pair them with the group by clause. Together this will count the records in the table, grouped by date.

For example, to see the user records counted by the date created, we use the date and count functions and group by clause as follows:

select date(created_at), count(1) from users group by date(created_at)

Use the date and count functions and group by clause to count and group the orders by the dates they were ordered_at.
select /**/
from orders
group by 1
order by 1;

We now have the daily order count! 

The order by 1 and group by 1 statements are shortcuts for order by date(ordered_at) and group by date(ordered_at). 

select date(created_at), count(1) from orders group by 1 order by 1;

We have the Daily Count of orders, but what we really want to know is revenue. How much money has SpeedySpoon made from orders each day?

We can make a few changes to our Daily Count query to get the revenue.

First, instead of using count(1) to count the rows per date, we'll use round(sum(amount_paid), 2) to add up the revenue per date. Complete the query by adding revenue per date.

Second, we need to join in the order_items table because that table has an amount_paid column representing revenue. Complete the query by adding a join clause where orders.id = order_items.order_id.

select date(ordered_at), round(sum(amount_paid), 2)
from orders
    join order_items on 
      orders.id = order_items.order_id
group by 1
order by 1;


Note that the round function rounds decimals to digits, based on the number passed in. Here round(..., 2) rounds the sum paid to two digits.

Nice. Now with a small change, we can find out how much we're making per day for any single dish. What's the daily revenue from customers ordering kale smoothies?

Complete the query by using a where clause to filter the daily sums down to orders where the name = 'kale-smoothie'.

select date(ordered_at), round(sum(amount_paid), 2)
from orders
    join order_items on 
      orders.id = order_items.order_id
where name = 'kale-smoothie'
group by 1
order by 1;

It looks like the smoothies might not be performing well, but to be sure we need to see how they're doing in the context of the other order items.

We'll look at the data several different ways, the first of which is determining what percent of revenue these smoothies represent.

To get the percent of revenue that each item represents, we need to know the total revenue of each item. We will later divide the per-item total with the overall total revenue.

The following query groups and sum the products by price to get the total revenue for each item. Complete the query by passing in 
sum(amount_paid) into the round function and rounding to two decimal places.

select name, round(sum(amount_paid), 2)
from order_items
group by name
order by 2 desc;

We have the sum of the the products by revenue, but we still need the percent. For that, we'll need to get the total using a subquery. A subquery can perform complicated calculations and create filtered or aggregate tables on the fly.

Subqueries are useful when you want to perform an aggregation outside the context of the current query. This will let us calculate the overall total and per-item total at the same time. 

Complete the denominator in the subquery, which is the total revenue from order_items. Use the sum function to query the amount_paid from the order_items table.

select name, 
round(sum(amount_paid) /
      (select sum(amount_paid) from order_items) * 100.0, 2) as pct 
      from order_items 
      group by 1 
      group by 2 desc;

We now have the percent or revenue each product represents! 

Here order by 2 desc sorts by the second column (the percent) to show the products in order of their contribution to revenue.

As we suspected, kale smoothies are not bringing in the money. And thanks to this analysis, we found what might be a trend - several of the other low performing products are also smoothies.

Let's keep digging to find out what's going on with these smoothies.

To see if our smoothie suspicion has merit, let's look at purchases by category. We can group the order items by what type of food they are, and go from there. Since our order_items table does not include categories already, we'll need to make some!

Previously we've been using group by with a column (like order_items.name) or a function (like date(orders.ordered_at)).

We can also use group by with expressions. In this case a case statement is just what we need to build our own categories. case statements are similar to if/else in other languages. 

Here's the basic structure of a case statement:

case {condition}
  when {value1} then {result1}
  when {value2} then {result2}
  else {result3}
end

We'll build our own categories using a case statement. Complete the query below with a case condition of name that lists out each product, and decides its group.

select *,
  /**/
    when 'kale-smoothie'    then 'smoothie'
    when 'banana-smoothie'  then 'smoothie'
    when 'orange-juice'     then 'drink'
    when 'soda'             then 'drink'
    when 'blt'              then 'sandwich'
    when 'grilled-cheese'   then 'sandwich'
    when 'tikka-masala'     then 'dinner'
    when 'chicken-parm'     then 'dinner'
     else 'other'
  end as category
from order_items
order by id
limit 100;

Note that the else 'other' block catches all the products that don't meet the previous conditions.

Complete the query by using the category column created by the case statement in our previous revenue percent calculation. Add the denominator that will sum the amount_paid.

select
  case name
    when 'kale-smoothie'    then 'smoothie'
    when 'banana-smoothie'  then 'smoothie'
    when 'orange-juice'     then 'drink'
    when 'soda'             then 'drink'
    when 'blt'              then 'sandwich'
    when 'grilled-cheese'   then 'sandwich'
    when 'tikka-masala'     then 'dinner'
    when 'chicken-parm'     then 'dinner'
    else 'other'
  end as category, round(1.0 * sum(amount_paid) /
    (select /**/ from order_items) * 100, 2) as pct
from order_items
group by 1
order by 2 desc;

Here 1.0 * is a shortcut to ensure the database represents the percent as a decimal.

We've learned how to write queries to retrieve information from the database. In this lesson we are going to learn how to perform calculations using SQL.

Aggregate functions compute a single result from a set of input values. For instance, when we need the sum or average of a particular column, we can use aggregate functions to quickly compute it for us. We will be learning about different aggregate functions in this lesson.

SQL:

SELECT COUNT(*) FROM fake_apps;

The fastest way to calculate the number of rows in a table is to use the COUNT() function.

COUNT() is a function that takes the name of a column as an argument and counts the number of rows where the column is not NULL. Here, we want to count every row so we pass * as an argument.

SQL:

SELECT price, COUNT(*) FROM fake_apps GROUP BY price;

Aggregate functions are more useful when they organize data into groups.

GROUP BY is a clause in SQL that is only used with aggregate functions. It is used in collaboration with the SELECT statement to arrange identical data into groups.

Here, our aggregate function is COUNT() and we are passing price as an argument to GROUP BY. SQL will count the total number of apps for each price in the table. 

It is usually helpful to SELECT the column you pass as an argument to GROUP BY. Here we select price and COUNT(*). You can see that the result set is organized into two columns making it easy to see the number of apps at each price.

SQL:

SELECT SUM(downloads) FROM fake_apps;

SQL makes it easy to add all values in a particular column using SUM().

SUM() is a function that takes the name of a column as an argument and returns the sum of all the values in that column. Here, it adds all the values in the downloads column.

SQL:

SELECT MAX(downloads) FROM fake_apps;

You can find the largest value in a column by using MAX().

MAX() is a function that takes the name of a column as an argument and returns the largest value in that column. Here, we pass downloads as an argument so it will return the largest value in the downloads column.

SQL:

SELECT MIN(downloads) FROM fake_apps;

Similar to MAX(), SQL also makes it easy to return the smallest value in a column by using the MIN() function.

MIN() is a function that takes the name of a column as an argument and returns the smallest value in that column. Here, we pass downloads as an argument so it will return the smallest value in the downloads column.

Return the names of the apps that have been downloaded the least number of times in each category.

SQL:

SELECT name, category, MIN(downloads) FROM fake_apps GROUP BY category;

====
SQL:

SELECT AVG(downloads) FROM fake_apps;

This statement returns the average number of downloads for an app in our database. SQL uses the AVG() function to quickly calculate the average value of a particular column.

The AVG() function works by taking a column name as an argument and returns the average value for that column.

Calculate the average number of downloads at each price. 

SELECT price, AVG(downloads) FROM fake_apps GROUP BY price;

SQL:

SELECT price, ROUND(AVG(downloads), 2) FROM fake_apps GROUP BY price;

By default, SQL tries to be as precise as possible without rounding. We can make the result set easier to read using the ROUND() function.

ROUND() is a function that takes a column name and an integer as an argument. It rounds the values in the column to the number of decimal places specified by the integer. Here, we pass the column AVG(downloads) and 2 as arguments. SQL first calculates the average for each price and then rounds the result to two decimal places in the result set.

Round the average number of downloads to the nearest integer for each price.

SELECT price, ROUND(AVG(downloads)) FROM fake_apps GROUP BY price;

Summary:
========

◼Aggregate functions combine multiple rows together to form a single value of more meaningful information.
◼COUNT takes the name of a column(s) as an argument and counts the number of rows where the value(s) is not NULL.
◼GROUP BY is a clause used with aggregate functions to combine data from one or more columns.
◼SUM() takes the column name as an argument and returns the sum of all the values in that column.
◼MAX() takes the column name as an argument and returns the largest value in that column.
◼MIN() takes the column name as an argument and returns the smallest value in that column.
◼AVG() takes a column name as an argument and returns the average value for that column.
◼ROUND() takes two arguments, a column name and the number of decimal places to round the values in that column.

So far we have learned how to build tables, write queries, and perform calculations using one table. In this lesson we will learn to query multiple tables that have relationships with each other.

Most of the time, data is distributed across multiple tables in the database. Imagine a database with two tables, artists and albums. An artist can produce many different albums, and an album is produced by an artist. 

The data in these tables are related to each other. Through SQL, we can write queries that combine data from multiple tables that are related to one another. This is one of the most powerful features of relational databases.

SQL:

CREATE TABLE artists(id INTEGER PRIMARY KEY, name TEXT)

Using the CREATE TABLE statement we added a PRIMARY KEY to the id column.

A primary key serves as a unique identifier for each row or record in a given table. The primary key is literally an id value for a record. We're going to use this value to connect artists to the albums they have produced.

By specifying that the id column is the PRIMARY KEY, SQL makes sure that:
◼None of the values in this column are NULL
◼Each value in this column is unique

A table can not have more than one PRIMARY KEY column. 

SQL:

SELECT * FROM albums WHERE artist_id = 3;
SELECT * FROM artists WHERE id = 3;

A foreign key is a column that contains the primary key of another table in the database. We use foreign keys and primary keys to connect rows in two different tables. One table's foreign key holds the value of another table's primary key. Unlike primary keys, foreign keys do not need to be unique and can be NULL.

Here, artist_id is a foreign key in the albums table. We can see that Michael Jackson has an id of 3 in the artists table. All of the albums by Michael Jackson also have a 3 in the artist_id column in the albums table.

This is how SQL is linking data between the two tables. The relationship between the artists table and the albums table is the id value of the artists.

SQL:

SELECT albums.name, albums.year, artists.name FROM albums, artists

One way to query multiple tables is to write a SELECT statement with multiple table names separated by a comma. This is also known as a cross join. Here, albums and artists are the different tables we are querying.

When querying more than one table, column names need to be specified by table_name.column_name. Here, the result set includes the name and year columns from the albums table and the name column from the artists table.

Unfortunately the result of this cross join is not very useful. It combines every row of the artists table with every row of the albums table. It would be more useful to only combine the rows where the album was created by the artist.

SQL:

SELECT * FROM albums JOIN artists ON albums.artist_id = artists.id;

In SQL, joins are used to combine rows from two or more tables. The most common type of join in SQL is an inner join. 

An inner join will combine rows from different tables if the join condition is true. Let's look at the syntax to see how it works.
1.SELECT * specifies the columns our result set will have. Here, we want to include every column in both tables.
2.FROM albums specifies the first table we are querying. 
3.JOIN artists ON specifies the type of join we are going to use as well as the name of the second table. Here, we want to do an inner join and the second table we want to query is artists.
4.albums.artist_id = artists.id is the join condition that describes how the two tables are related to each other. Here, SQL uses the foreign key column artist_id in the albums table to match it with exactly one row in the artists table with the same value in the id column. We know it will only match one row in the artists table because id is the PRIMARY KEY of artists.

SQL:
SELECT * FROM  albums LEFT JOIN artists ON albums.artist_id = artists.id;

Outer joins also combine rows from two or more tables, but unlike inner joins, they do not require the join condition to be met. Instead, every row in the left table is returned in the result set, and if the join condition is not met, then NULL values are used to fill in the columns from the right table.

The left table is simply the first table that appears in the statement. Here, the left table is albums. Likewise, the right table is the second table that appears. Here, artists is the right table.

SQL:
SELECT albums.name AS 'Album', albums.year, artists.name AS 'Artist' FROM albums JOIN artists ON albums.artist_id = artists.id WHERE albums.year > 1980;

AS is a keyword in SQL that allows you to rename a column or table using an alias. The new name can be anything you want as long as you put it inside of single quotes. Here we want to rename the albums.name column as 'Album', and the artists.name column as 'Artist'.

It is important to note that the columns have not been renamed in either table. The aliases only appear in the result set.

Summary:
========

◼Primary Key is a column that serves a unique identifier for row in the table. Values in this column must be unique and cannot be NULL.
◼Foreign Key is a column that contains the primary key to another table in the database. It is used to identify a particular row in the referenced table.
◼Joins are used in SQL to combine data from multiple tables.
◼INNER JOIN will combine rows from different tables if the join condition is true.
◼LEFT OUTER JOIN will return every row in the left table, and if the join condition is not met, NULL values are used to fill in the columns from the right table.
◼AS is a keyword in SQL that allows you to rename a column or table in the result set using an alias.

One way to easily create and organize temporary results in a query is with CTEs, Common Table Expressions, also known as with clauses. The with clauses make it easy to define and use results in a more organized way than subqueries.

These clauses usually look like this:
  with {subquery_name} as (
    {subquery_body}
  )
  select ...
  from {subquery_name}
  where ...

Working example : 

with daily_revenue as (
  select
  	date(created_at) as dt,
  	round(sum(price), 2) as rev
  from purchases
  where refunded_at is null
  group by 1
  )
  select * from daily_revenue order by dt;

And one of multiple CTEs in the same script (note : you don't need to repeat "with")

with daily_revenue as (
  select
  	date(created_at) as dt,
  	round(sum(price), 2) as rev
  from purchases
  where refunded_at is null
  group by 1
  ),
	daily_players as (
    select
    	 date(created_at) as dt,
  		count(distinct(user_id)) as players
    from gameplays
    group by 1
    )
  
  select * from daily_players order by dt;

Here's a development on the previous script. This makes use of the term "using" in the join clause.

Now that we have the revenue and DAU, join them on their dates and calculate daily ARPU. Complete the query by adding the keyword using in the join clause.
/**/ daily_revenue as (
  select
    date(created_at) as dt,
    round(sum(price), 2) as rev
  from purchases
  where refunded_at is null
  group by 1
),
daily_players as (
  select
    /**/ as dt,
    /**/ as players
  from gameplays
  group by 1
)
select
  daily_revenue.dt,
  daily_revenue.rev / daily_players.players
from daily_revenue
  join daily_players /**/ (dt);

In the final select statement, daily_revenue.dt represents the date, while daily_revenue.rev / daily_players.players is the daily revenue divided by the number of players that day. In full, it represents how much the company is making per player, per day. 

In our query, we used using instead of on in the join clause. This is a special case join.

from daily_revenue
  join daily_players using (dt);

When the columns to join have the same name in both tables you can use using instead of on. Our use of the using keyword is in this case equivalent to this clause:

from daily_revenue
  join daily_players on
    daily_revenue.dt = daily_players.dt;

Now let's find out what percent of Mineblock players are returning to play the next day. This KPI is called 1 Day Retention.

Retention can be defined many different ways, but we'll stick to the most basic definition. For all players on Day N, we'll consider them retained if they came back to play again on Day N+1.

This will let us track whether or not Mineblocks is getting "stickier" over time. The stickier our game, the more days players will spend in-game.

And more time in-game means more opportunities to monetize and grow our business.

Before we can calculate retention we need to get our data formatted in a way where we can determine if a user returned.

Currently the gameplays table is a list of when the user played, and it's not easy to see if any user came back.

By using a self-join, we can make multiple gameplays available on the same row of results. This will enable us to calculate retention. 

The power of self-join comes from joining every row to every other row. This makes it possible to compare values from two different rows in the new result set. In our case, we'll compare rows that are one date apart from each user.

1.

To calculate retention, start from a query that selects the date(created_at) as dt and user_id columns from the gameplays table.
 
select
  date(created_at) as dt,
  user_id
from gameplays as g1
order by dt
limit 100;

2.

Now we'll join gameplays on itself so that we can have access to all gameplays for each player, for each of their gameplays.

This is known as a self-join and will let us connect the players on Day N to the players on Day N+1. In order to join a table to itself, it must be aliased so we can access each copy separately.

We aliased gameplays in the query above because in the next step, we need to join gameplays to itself so we can get a result selecting [date, user_id, user_id_if_retained].

Complete the query by using a join statement to join gameplays to itself on user_id using the aliases g1 and g2.

select
  date(g1.created_at) as dt,
  g1.user_id
from gameplays as g1
join gameplays as g2 on
g1.user_id = g2.user_id
order by 1
limit 100;

We don't use the "using" clause here because the join is about to get more complicated.

Now that we have our gameplays table joined to itself, we can start to calculate retention.

1 Day Retention is defined as the number of players who returned the next day divided by the number of original players, per day. Suppose 10 players played Mineblocks on Dec 10th. If 4 of them play on Dec 11th, the 1 day retention for Dec 10th is 40%. 

1.

The previous query joined all rows in gameplays against all other rows for each user, making a massive result set that we don't need.

We'll need to modify this query. 

select
  date(g1.created_at) as dt,
  g1.user_id,
  g2.user_id
from gameplays as g1
  join gameplays as g2 on
    g1.user_id = g2.user_id
    and date(g1.created_at) = date(datetime(g2.created_at, '-1 day'))
order by 1
limit 100;

Complete the query above such that the join clause includes a date join:
date(g1.created_at) = date(datetime(g2.created_at, '-1 day'))

This means "only join rows where the date in g1 is one less than the date in g2", which makes it possible to see if users have returned!

2.

The query above won't return meaningful results because we're using an inner join. This type of join requires that the condition be met for all rows, effectively limiting our selection to only the users that have returned.

Instead, we want to use a left join, this way all rows in g1 are preserved, leaving nulls in the rows from g2 where users did not return to play the next day.

Change the join clause to use left join and count the distinct number of users from g1 and g2 per date.

select
  date(g1.created_at) as dt,
  g1.user_id,
  g2.user_id
from gameplays as g1
  left join gameplays as g2 on
    g1.user_id = g2.user_id
    and date(g1.created_at) = date(datetime(g2.created_at, '-1 day'))
order by 1
limit 100;

3.

Now that we have retained users as count(distinct g2.user_id) and total users as count(distinct g1.user_id), divide retained users by total users to calculate 1 day retention!

select
  date(g1.created_at) as dt,
  round(100 * count(distinct g2.user_id) /
    count(distinct g1.user_id)) as retention
from gameplays as g1
  left join gameplays as g2 on
    g1.user_id = g2.user_id
    and date(g1.created_at) = date(datetime(g2.created_at, '-1 day'))
order by 1
limit 100;

While every business has different metrics to track their success, most are based on revenue and usage.

The metrics in this lesson are merely a starting point, and from here you'll be able to create and customize metrics to track whatever is most important to your company.

And remember, data science is exploratory! The current set of metrics can always be improved and there's usually more to any spike or dip than what immediately meets the eye.

Let's generalize what we've learned so far:
◼Key Performance Indicators are high level health metrics for a business.
◼Daily Revenue is the sum of money made per day. 
◼Daily Active Users are the number of unique users seen each day
◼Daily Average Revenue Per Purchasing User (ARPPU) is the average amount of money spent by purchasers each day.
◼Daily Average Revenue Per User (ARPU) is the average amount of money across all users.
◼1 Day Retention is defined as the number of players from Day N who came back to play again on Day N+1.
